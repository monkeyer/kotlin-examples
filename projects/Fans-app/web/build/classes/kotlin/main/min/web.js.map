{"version":3,"file":"web.js","sources":["../../../../src/main/kotlin/com/fans/kotlinconf/api/SessionsAPI.kt","JSON.kt","../../../../src/main/kotlin/com/fans/kotlinconf/api/ajaxUtil.kt","coroutines/experimental/CoroutinesLibrary.kt","../../../../src/main/kotlin/com/fans/kotlinconf/apis.kt","../../../../src/main/kotlin/com/fans/kotlinconf/components/SessionComponent.kt","react/dom/ReactDOMTags.kt","../../../../src/main/kotlin/com/fans/kotlinconf/components/util.kt","util/Standard.kt","text/Strings.kt","kotlinext/js/Helpers.kt","../../../../../../../../../../../../dummy.kt","../../../../src/main/kotlin/com/fans/kotlinconf/components/SessionsComponent.kt","../../../../src/main/kotlin/com/fans/kotlinconf/components/routingDsl.kt","../../../../src/main/kotlin/com/fans/kotlinconf/main.kt"],"sourcesContent":["package com.fans.kotlinconf.api\n\n\nimport com.fans.kotlinconf.SessionModel\nimport com.fans.kotlinconf.data.AllData\nimport com.fans.kotlinconf.data.Session\nimport org.w3c.dom.WebSocket\nimport kotlin.browser.window\nimport kotlin.js.JSON\nimport kotlinx.serialization.json.JSON as KJSON\n\nclass SessionsAPI(private val baseUrl: String, private val baseWsUrl: String) {\n    private suspend fun fetchAll(): AllData {\n        val rawData = httpGet(\"$baseUrl/all\")\n        return KJSON.parse<AllData>(rawData)\n    }\n\n    suspend fun fetchSessions(): List<Session> = fetchAll().sessions ?: emptyList()\n\n    suspend fun fetchSession(id: String): SessionModel? {\n        val all = fetchAll()\n        return SessionModel.forSession(all, id)\n    }\n\n    fun subscribeToVotes(id: String, callback: (Votes?) -> Unit): VotesSubscription {\n        var currentWs: WebSocket? = null\n        var closing = false\n        fun connect() {\n            if (closing) return\n            println(\"Connected to websocket\")\n            val ws = WebSocket(\"$baseWsUrl/sessions/$id/votes\")\n            ws.onopen = {\n                currentWs = ws\n                ws.onmessage = { event ->\n                    callback(JSON.parse(event.asDynamic().data.unsafeCast<String>()))\n                }\n                ws.onclose = {\n                    println(\"Disconnected from websocket\")\n                    window.setTimeout({ connect() }, 1000)\n                }\n                null\n            }\n            ws.onerror = {\n                window.setTimeout({ connect() }, 1000)\n            }\n        }\n        connect()\n\n        return object : VotesSubscription {\n            override fun close() {\n                println(\"Connection closed\")\n                closing = true\n                currentWs?.close()\n            }\n        }\n    }\n}\n\n",null,"package com.fans.kotlinconf.api\n\n\nimport org.w3c.xhr.XMLHttpRequest\nimport kotlin.coroutines.experimental.*\nimport kotlin.js.Promise\n\nsuspend fun httpGet(url: String): String = suspendCoroutine { c ->\n    val xhr = XMLHttpRequest()\n    xhr.onreadystatechange = {\n        if (xhr.readyState == XMLHttpRequest.DONE) {\n            if (xhr.status / 100 == 2) {\n                c.resume(xhr.response as String)\n            }\n            else {\n                c.resumeWithException(RuntimeException(\"HTTP error: ${xhr.status}\"))\n            }\n        }\n        null\n    }\n    xhr.open(\"GET\", url)\n    xhr.send()\n}\n\nfun <T> async(x: suspend () -> T): Promise<T> {\n    return Promise { resolve, reject ->\n        x.startCoroutine(object : Continuation<T> {\n            override val context = EmptyCoroutineContext\n\n            override fun resume(value: T) {\n                resolve(value)\n            }\n\n            override fun resumeWithException(exception: Throwable) {\n                reject(exception)\n            }\n        })\n    }\n}","/*\n * Copyright 2010-2017 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n@file:kotlin.jvm.JvmName(\"CoroutinesKt\")\npackage kotlin.coroutines.experimental\n\nimport kotlin.coroutines.experimental.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn\nimport kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked\n\n/**\n * Starts coroutine with receiver type [R] and result type [T].\n * This function creates and start a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n        receiver: R,\n        completion: Continuation<T>\n) {\n    createCoroutineUnchecked(receiver, completion).resume(Unit)\n}\n\n/**\n * Starts coroutine without receiver and with result type [T].\n * This function creates and start a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend  () -> T).startCoroutine(\n        completion: Continuation<T>\n) {\n    createCoroutineUnchecked(completion).resume(Unit)\n}\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n * Repeated invocation of any resume function on the resulting continuation produces [IllegalStateException].\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n        receiver: R,\n        completion: Continuation<T>\n): Continuation<Unit> = SafeContinuation(createCoroutineUnchecked(receiver, completion), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n * Repeated invocation of any resume function on the resulting continuation produces [IllegalStateException].\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n        completion: Continuation<T>\n): Continuation<Unit> = SafeContinuation(createCoroutineUnchecked(completion), COROUTINE_SUSPENDED)\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Repeated invocation of any resume function produces [IllegalStateException].\n */\n@SinceKotlin(\"1.1\")\npublic inline suspend fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T =\n        suspendCoroutineOrReturn { c: Continuation<T> ->\n            val safe = SafeContinuation(c)\n            block(safe)\n            safe.getResult()\n        }\n\n// INTERNAL DECLARATIONS\n\n@kotlin.internal.InlineOnly\ninternal inline fun processBareContinuationResume(completion: Continuation<*>, block: () -> Any?) {\n    try {\n        val result = block()\n        if (result !== COROUTINE_SUSPENDED) {\n            @Suppress(\"UNCHECKED_CAST\")\n            (completion as Continuation<Any?>).resume(result)\n        }\n    } catch (t: Throwable) {\n        completion.resumeWithException(t)\n    }\n}\n","package com.fans.kotlinconf\n\n\nimport com.fans.kotlinconf.api.SessionsAPI\nimport kotlin.browser.window\n\nval sessionsAPI = SessionsAPI(\n        baseUrl = \"\",\n        baseWsUrl = getWsServer()\n)\n\nprivate fun getWsServer(): String {\n    val location = window.location\n    val wsProtocol = if (location.protocol == \"https:\") \"wss\" else \"ws\"\n    return \"$wsProtocol://${location.host}\"\n}","package com.fans.kotlinconf.components\n\n\nimport com.fans.kotlinconf.SessionModel\nimport kotlinext.js.jsObject\nimport com.fans.kotlinconf.api.Votes\nimport com.fans.kotlinconf.api.VotesSubscription\nimport com.fans.kotlinconf.api.async\nimport com.fans.kotlinconf.sessionsAPI\nimport react.*\nimport react.dom.div\nimport react.dom.p\nimport react.dom.span\nimport kotlin.browser.window\nimport kotlin.js.Json\n//import kotlin.js.Math\nimport kotlin.js.json\n\nclass SessionComponent : RComponent<RouteResultProps<SessionProps>, SessionState>() {\n    private var votesSubscription: VotesSubscription? = null\n    private var mounted = false\n\n    override fun RBuilder.render(): ReactElement? = div(classes = \"session-view\") {\n        loading(state.session) { session ->\n            div(classes = \"session-app-title\") { +\"KotlinConf App\" }\n\n            div(classes = \"session-badges\") {\n                for (badge in arrayOf(\"app-store\", \"google-play\")) {\n                    span(classes = \"session-badge session-badge-$badge\") {  }\n                    +\" \"\n                }\n            }\n\n            div(classes = \"session-block\") {\n                renderSessionBlock(session)\n            }\n\n            val votes = state.votes\n            if (votes != null) {\n                renderVotes(votes)\n            } else {\n                div(classes = \"session-votes-unavailable\") {\n                    +\"Sorry, votes information unavailable\"\n                }\n            }\n        }\n    }\n\n    private fun RBuilder.renderSessionBlock(session: SessionModel) {\n        div(classes = \"session-info-block\") {\n            div(classes = \"session-title\") {\n                +session.title\n            }\n\n            div(classes = \"session-speakers\") {\n                span(classes = \"session-speakers-label\") { +\"By \" }\n                for ((index, speaker) in session.speakers.withIndex()) {\n                    if (index > 0) {\n                        span(classes = \"session-speaker-separator\") { +\", \" }\n                    }\n                    span(classes = \"session-speaker\") { +(speaker.fullName ?: \"<Unknown name>\") }\n                }\n            }\n\n            div(classes = \"session-description\") {\n                div(classes = \"session-subtitle\") {\n                    dateRange(session.startsAt to session.endsAt)\n                    session.room?.let { div(classes = \"session-room\") { +it } }\n                }\n\n                for (part in session.description.split(lineSeparatorRegex)) {\n                    p {\n                        +part\n                    }\n                }\n            }\n        }\n\n        div(classes = \"session-smiles-label\") { +\"Tap to rate:\" }\n\n        div(classes = \"session-smiles\") {\n            for (mood in arrayOf(\"happy\", \"neutral\", \"unhappy\")) {\n                +\" \"\n                span(classes = \"session-smile-small session-smile-small-$mood\") {  }\n            }\n        }\n\n        div(classes = \"session-circle\") { }\n    }\n\n    private fun RBuilder.renderVotes(votes: Votes) {\n        val votesList = listOf(votes.good, votes.bad, votes.soso)\n        val total = votesList.sum()\n\n        fun percentage(value: Int) = if (total == 0) 0.0 else value.toDouble() / total.toDouble()\n        var votePosition = 0.0\n        fun RBuilder.votes(id: String, value: Int) {\n            child(\"div\", jsObject<StyledSpanProps> {}) {\n                val percent = percentage(value)\n\n                attrs {\n                    classes = \"session-votes-$id\"\n                    style = json(\n                            \"width\" to percent.asRelativePosition(),\n                            \"left\" to votePosition.asRelativePosition()\n                    )\n                }\n\n                votePosition += percent\n\n                div(\"session-votes-content\") {\n                    div(\"session-votes-cell\") {\n                        span(classes = \"session-votes-cell-hack\") { +\"\\u00A0\" }\n                        div(\"session-votes-container\") {\n                            span(classes = \"session-votes-label\") { +\"\\u00A0\" }\n                            span(classes = \"session-votes-count-percentage\") { +\"${kotlin.math.round(percent * 100)}%\" }\n                            span(classes = \"session-votes-count-absolute\") { +\"$value votes\" }\n                        }\n                    }\n                }\n            }\n        }\n\n        div(classes = \"session-votes-total\") { +\"Total: $total votes \" }\n        div(classes = \"session-votes\") {\n            votes(\"good\", votes.good)\n            votes(\"soso\", votes.soso)\n            votes(\"bad\", votes.bad)\n        }\n    }\n\n    private fun Double.asRelativePosition() = (this * 100).toFixed(2) + \"%\"\n\n    override fun componentDidMount() {\n        mounted = true\n        loadData()\n        subscribeToVotes()\n    }\n\n    override fun componentWillUnmount() {\n        mounted = false\n        votesSubscription?.close()\n    }\n\n    private fun loadData() {\n        if (!mounted) return\n\n        async {\n            updateState {\n                session = sessionsAPI.fetchSession(props.match.params.id)\n            }\n        }\n\n        window.setTimeout(this::loadData, 10000)\n    }\n\n    private fun subscribeToVotes() {\n        votesSubscription = sessionsAPI.subscribeToVotes(props.match.params.id) {\n            updateState {\n                votes = it\n            }\n        }\n    }\n}\n\nexternal interface SessionProps : RProps {\n    var id: String\n}\n\nexternal interface SessionState : RState {\n    var session: SessionModel?\n    var votes: Votes?\n}\n\nprivate external interface StyledSpanProps : RProps {\n    @JsName(\"className\")\n    var classes: String\n\n    @JsName(\"style\")\n    var style: Json\n}\n\nprivate val lineSeparatorRegex = Regex(\"\\\\r|\\\\n|\\\\r|\\\\n\")",null,"package com.fans.kotlinconf.components\n\n\nimport com.fans.kotlinconf.Date\nimport com.fans.kotlinconf.parseDate\nimport com.fans.kotlinconf.toReadableDateTimeString\nimport com.fans.kotlinconf.toReadableString\nimport kotlinext.js.clone\nimport kotlinext.js.jsObject\nimport react.RBuilder\nimport react.RState\nimport react.React\nimport react.dom.div\nimport react.dom.span\n\ninline fun <T : RState> React.Component<*, T>.setState(action: T.() -> Unit) {\n    setState(jsObject(action))\n}\n\ninline fun <T : RState> React.Component<*, T>.updateState(action: T.() -> Unit) {\n    setState(clone(state).apply(action))\n}\n\ninline fun <T> RBuilder.loading(value: T?, action: (T) -> Unit) {\n    if (value == null) {\n        div(classes = \"loading\") {\n            +\"Loading data...\"\n        }\n    }\n    else {\n        action(value)\n    }\n}\n\nfun RBuilder.dateRange(range: Pair<String?, String?>) =\n        dateRange(range.first?.let { parseDate(it) } to range.second?.let { parseDate(it) })\n\nfun RBuilder.dateRange(range: Pair<Date?, Date?>) {\n    val (startsAt, endsAt) = range\n    div(classes = \"session-time\") {\n        if (startsAt != null) {\n            +if (endsAt != null) {\n                (startsAt to endsAt).toReadableString()\n            }\n            else {\n                startsAt.toReadableDateTimeString()\n            }\n        }\n        else {\n            span(classes = \"session-time-unknown\") { +\"Time unknown\" }\n        }\n    }\n}\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun Double.toFixed(precision: Int): String = asDynamic().toFixed(precision)","@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R = block()\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R = block()\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R = receiver.block()\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T { block(); return this }\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T { block(this); return this }\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R = block(this)\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? = if (predicate(this)) this else null\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? = if (!predicate(this)) this else null\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    for (index in 0..times - 1) {\n        action(index)\n    }\n}","/*\n * Copyright 2010-2016 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\n\npackage kotlin.text\n\nimport kotlin.comparisons.*\nimport kotlin.internal.contracts.*\n\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        }\n        else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String\n        = (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String\n        = (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String\n        = (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @returns Returns a string, of length at least [length], consisting of string prepended with [padChar] as many times.\n * as are necessary to reach that length.\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @returns Returns a string, of length at least [length], consisting of string prepended with [padChar] as many times.\n * as are necessary to reach that length.\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String\n        = (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @returns Returns a string, of length at least [length], consisting of string prepended with [padChar] as many times.\n * as are necessary to reach that length.\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @returns Returns a string, of length at least [length], consisting of string prepended with [padChar] as many times.\n * as are necessary to reach that length.\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String\n        = (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String\n        = (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence\n        = replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String\n        = (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String\n        = (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String\n        = (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String = regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length)\n            || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0..length-1) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n        this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n        this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\nprivate fun CharSequence.findAnyOf(chars: CharArray, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, Char>? {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        val index = if (!last) nativeIndexOf(char, startIndex) else nativeLastIndexOf(char, startIndex)\n        return if (index < 0) null else index to char\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..lastIndex else startIndex.coerceAtMost(lastIndex) downTo 0\n    for (index in indices) {\n        val charAtIndex = get(index)\n        val matchingCharIndex = chars.indexOfFirst { it.equals(charAtIndex, ignoreCase) }\n        if (matchingCharIndex >= 0)\n            return index to chars[matchingCharIndex]\n    }\n\n    return null\n}\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @returns An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(chars, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @returns An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(chars, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @returns An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @returns An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n        indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(private val input: CharSequence, private val startIndex: Int, private val limit: Int, private val getNextMatch: CharSequence.(Int) -> Pair<Int, Int>?): Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            }\n            else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                }\n                else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    }\n                    else {\n                        val (index,length) = match\n                        nextItem = currentStartIndex..index-1\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { startIndex -> findAnyOf(delimiters, startIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to 1 } })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { startIndex -> findAnyOf(delimitersList, startIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n        rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> =\n        rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n        rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> =\n        rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n",null,null,"package com.fans.kotlinconf.components\n\n\nimport com.fans.kotlinconf.data.Session\nimport com.fans.kotlinconf.api.async\nimport com.fans.kotlinconf.sessionsAPI\nimport react.*\nimport react.dom.div\nimport kotlin.browser.window\n\n\nclass SessionsComponent : RComponent<RProps, SessionsState>() {\n    private var mounted = false\n\n    override fun RBuilder.render(): ReactElement? = div(classes = \"sessions\") {\n        loading(state.sessions ?: state.sessionsError) {\n            val err = state.sessionsError\n            if (err != null) {\n                div {\n                    +err\n                }\n            }\n            else {\n                for (session in state.sessions!!) {\n                    div(classes = \"session\") {\n                        div(classes = \"session-title\") {\n                            routeLink(\"/session/${session.id}\") {\n                                +(session.title ?: \"<untitled>\")\n                            }\n                        }\n\n                        dateRange(session.startsAt to session.endsAt)\n                    }\n                }\n            }\n        }\n    }\n\n    override fun componentDidMount() {\n        mounted = true\n        loadData()\n    }\n\n    override fun componentWillUnmount() {\n        mounted = false\n    }\n\n    private fun loadData() {\n        if (!mounted) return\n\n        async {\n            setState {\n                try {\n                    sessions = sessionsAPI.fetchSessions()\n                    sessionsError = null\n                } catch (e: Exception) {\n                    sessionsError = \"Error loading list of sessions:\" + e.message\n                }\n            }\n        }\n\n        window.setTimeout(this::loadData, 10000)\n    }\n}\n\nexternal interface SessionsState : RState {\n    var sessions: List<Session>?\n    var sessionsError: String?\n}","package com.fans.kotlinconf.components\n\n\nimport react.*\nimport kotlin.reflect.KClass\n\nfun RBuilder.hashRouter(handler: RHandler<RProps>) = child(HashRouterComponent::class, handler)\n\nfun RBuilder.switch(handler: RHandler<RProps>) = child(SwitchComponent::class, handler)\n\nfun RBuilder.route(path: String, component: KClass<out React.Component<*, *>>, exact: Boolean = false) =\n        child(RouteComponent::class) {\n            attrs {\n                this.path = path\n                this.exact = exact\n                this.component = component.js.unsafeCast<RClass<RProps>>()\n            }\n        }\n\nfun RBuilder.routeLink(to: String, handler: RHandler<RProps>) = child(LinkComponent::class) {\n    attrs {\n        this.to = to\n    }\n    handler()\n}","package com.fans.kotlinconf\n\nimport com.fans.kotlinconf.components.*\nimport react.dom.render\nimport kotlin.browser.document\nimport kotlin.browser.window\n\nfun main(args: Array<String>) {\n    window.onload = {\n        render(document.getElementById(\"root\")!!) {\n            hashRouter {\n                switch {\n                    route(\"/\", SessionsComponent::class, exact = true)\n                    route(\"/session/:id\", SessionComponent::class)\n                }\n            }\n        }\n    }\n}"],"names":[],"mappings":"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E,oBAAI,gBAAgB,OAAhB,EAAyB,eAAzB,CAAJ,EAAuC,EAAvC,C;IAAF,C;EAAA,C;;IA7DpF,kBAArB,qBA6DyG,WD9CjD,cC8CiD,CA7DzG,C;IDgBF,YAAQ,UAAM,Q;IEClB,IAAI,aAAJ,C;MDjB2B,oBAArB,qBA6DyG,aC3C7F,SD2C6F,CA7DzG,C;MEyC8C,aDtB5C,mBAAC,iBAAD,C;MCsB4C,WFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;;;MCtChG,cAAO,K;MDvBgB,oBAArB,qBA6DyG,WD5CzF,mBC4CyF,CA7DzG,C;MEyC8C,aHxBP,mBAAC,gBAAD,C;MGwBO,WFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;MA7DzE,oBAArB,qBA6DyG,WD1CzF,gBC0CyF,CA7DzG,C;MDoBoB,gB;MAAA,QAAQ,WAAR,EAAqB,aAArB,C;MAAd,kD;QAAc,YAAd,Y;QCpBe,oBAArB,qBAsL2G,YDjKlF,iCAA8B,KCiKoD,CAtL3G,C;QEyC8C,aFzCpD,cAsLsG,CE7IlC,aFvClE,SAoLoG,C;QE7IlD,aHnBpC,mBAAC,GAAD,C;;MGmBoC,WFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;MA7DzE,oBAArB,qBA6DyG,WDnCzF,eCmCyF,CA7DzG,C;MD2BM,0BGcwC,aHdxC,U;MGcwC,WFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;MD/B5F,YAAY,UAAM,M;MAClB,IAAI,aAAJ,C;QACI,mBGSwC,WHTxC,EAAY,KAAZ,C;;;QChCe,oBAArB,qBA6DyG,WD3BrF,2BC2BqF,CA7DzG,C;QEyC8C,aHNpC,mBAAC,sCAAD,C;QGMoC,WFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;;;ID9CpD,OCfhD,wBEyCoE,WFvClE,SAFF,C;EDegD,C;EC2IpD,4F;;IAA+G,qB;MAAE,kBAAE,gBAAgB,OAAhB,EAAyB,eAAzB,CAAF,EAAqC,EAArC,C;IAAF,C;EAAA,C;;IA1JhF,kBAArB,qBA6DyG,WDnB7F,oBCmB6F,CA7DzG,C;IAAqB,oBAArB,qBA6DyG,WDlBzF,eCkByF,CA7DzG,C;IEyC8C,aHGxC,mBAAS,aAAT,C;IGHwC,WFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;IA7DzE,oBAArB,qBA6DyG,WDdzF,kBCcyF,CA7DzG,C;IDiD+B,Q;ICjDV,oBAArB,qBAsL2G,YDtItF,wBCsIsF,CAtL3G,C;IEyC8C,aHOG,mBAAC,KAAD,C;IGPH,aFzCpD,cAsLsG,CE7IlC,aFvClE,SAoLoG,C;IDrIjE,OAAiB,UAAT,gBAAS,CAAjB,W;IAAzB,OAAyB,cAAzB,C;MAAyB,wB;MAApB,IAAC,2BAAD,EAAQ,6B;MACT,IAAI,QAAQ,CAAZ,C;QClDW,oBAArB,qBAsL2G,YDnI9E,2BCmI8E,CAtL3G,C;QEyC8C,aHUc,mBAAC,IAAD,C;QGVd,aFzCpD,cAsLsG,CE7IlC,aFvClE,SAoLoG,C;;MAtL3E,oBAArB,qBAsL2G,YDjIlF,iBCiIkF,CAtL3G,C;MDqDwD,U;MGZV,aHYA,mBAAE,CAAQ,yBAAR,qBAAoB,gBAAtB,C;MGZA,aFzCpD,cAsLsG,CE7IlC,aFvClE,SAoLoG,C;;IE7IlD,WFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;IA7DzE,oBAArB,qBA6DyG,WDJzF,qBCIyF,CA7DzG,C;ID+DmB,U;IC/DE,oBAArB,qBA6DyG,WDHrF,kBCGqF,CA7DzG,C;ID4DkB,U;IADR,YGlBoC,aHkBpC,EAAU,GAAQ,gBAAR,EAA4B,cAA5B,CAAV,C;IACA,KAAQ,qBAAR,U;MC5DW,oBAArB,qBA6DyG,WDD7D,cCC6D,CA7DzG,C;MEyC8C,aHmBgB,0B;MGnBhB,aFzCpD,eEyCoE,aFvClE,SAFF,C;;IEyCoD,aFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;IDEvD,kBAAZ,mB;IAAR,SAA0B,kBIqmCkC,eAAM,WAAN,EAAzB,CAAyB,CJrmC5D,W;IAAb,OAAa,gBAAb,C;MAAa,wB;MC/DE,oBAArB,qBA0JqG,SAArE,IAAqE,CA1JrG,C;MEyC8C,aHwBhC,wB;MGxBgC,aFzCpD,cA0JgG,CEjH5B,aFvClE,SAwJ8F,C;;IEjH5C,WFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;IA7DpG,uBA6DoG,CEpBhC,WFvClE,SA2DkG,C;IA7DzE,oBAArB,qBA6DyG,WDU7F,sBCV6F,CA7DzG,C;IEyC8C,aH8BR,mBAAC,cAAD,C;ICvE5C,uBA6DoG,CEpBhC,aFvClE,SA2DkG,C;IA7DzE,qBAArB,qBA6DyG,WDY7F,gBCZ6F,CA7DzG,C;ID0Ee,kB;IAAA,UAAQ,OAAR,EAAiB,SAAjB,EAA4B,SAA5B,C;IAAb,oD;MAAa,WAAb,c;MGjC4C,cHkCxC,mBAAC,GAAD,C;MC3Ee,qBAArB,qBAsL2G,YD1GtF,6CAA0C,IC0G4C,CAtL3G,C;MEyC8C,cFzCpD,cAsLsG,CE7IlC,cFvClE,SAoLoG,C;;IAtLtG,uBA6DoG,CEpBhC,cFvClE,SA2DkG,C;IA7DzE,qBAArB,qBA6DyG,WDmB7F,gBCnB6F,CA7DzG,C;IAAN,uBA6DoG,CEpBhC,cFvClE,SA2DkG,C;EDoBpG,C;;IAMI,wB;MAA6B,OAAI,kBAAS,CAAb,GAAgB,GAAhB,GAA+B,KAAN,GAAyB,a;IAA/E,C;EAAA,C;;IAMc,4B;MACF,sBAAU,mBAAgB,U;MAC1B,kBAAQ,MACA,YAAmB,2CAAR,eAAQ,CAAnB,CADA,EAEA,WAAuB,2CAAb,sBAAa,CAAvB,CAFA,E;MAIZ,W;IANM,C;EAAA,C;;IAHiC,4B;MACvC,cAAc,mBAAW,aAAX,C;MAEd,wBAAM,kHAAN,C;MAQA,0BAAgB,O;MAEhB,cAAI,uB;MCvGW,kBAArB,qBA6DyG,mBA7DzG,C;MDuGmC,mC;MCvGd,oBAArB,qBA6DyG,WD2C3F,oBC3C2F,CA7DzG,C;MAAqB,oBAArB,qBAsL2G,YD7E9E,yBC6E8E,CAtL3G,C;MEyC8C,aHgEY,mBAAC,MAAD,C;MGhEZ,aFzCpD,cAsLsG,CE7IlC,aFvClE,SAoLoG,C;MAtL3E,oBAArB,qBA6DyG,WD6CvF,yBC7CuF,CA7DzG,C;MAAqB,oBAArB,qBAsL2G,YD3E1E,qBC2E0E,CAtL3G,C;MEyC8C,aHkEY,mBAAC,MAAD,C;MGlEZ,aFzCpD,cAsLsG,CE7IlC,aFvClE,SAoLoG,C;MAtL3E,oBAArB,qBAsL2G,YD1E1E,gCC0E0E,CAtL3G,C;MEyC8C,aHmEuB,mBAAgB,MAAM,UAAU,GAAhB,CAAf,iBAAD,C;MGnEvB,aFzCpD,cAsLsG,CE7IlC,aFvClE,SAoLoG,C;MAtL3E,oBAArB,qBAsL2G,YDzE1E,8BCyE0E,CAtL3G,C;MEyC8C,aHoEqB,mBAAC,qCAAD,C;MGpErB,aFzCpD,cAsLsG,CE7IlC,aFvClE,SAoLoG,C;ME7IlD,aFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;MEpBhD,WFzCpD,cA6DoG,CEpBhC,aFvClE,SA2DkG,C;MA7DpG,uBA6DoG,CEpBhC,WFvClE,SA2DkG,C;MDoD5F,W;IAvB2C,C;EAAA,C;;IAD/C,uC;MK7FJ,UAAa,E;ML8FL,wBAAM,KAAN,EK7FD,GL6FC,EAA2C,qHAA3C,C;IADJ,C;EAAA,C;;IALA,gBAAgB,QAAO,KAAM,KAAb,EAAmB,KAAM,IAAzB,EAA8B,KAAM,KAApC,E;IAChB,YAAsB,IAAV,SAAU,C;IAEtB,+D;IACA,uBAAmB,GAAnB,C;IACA,gF;ICzFuB,kBAArB,qBA6DyG,WDuD7F,qBCvD6F,CA7DzG,C;IEyC8C,WH2ET,mBAAC,6BAAD,C;ICpH3C,uBA6DoG,CEpBhC,WFvClE,SA2DkG,C;IA7DzE,oBAArB,qBA6DyG,WDwD7F,eCxD6F,CA7DzG,C;IDsHE,QG7E4C,aH6E5C,EAAM,MAAN,EAAoB,UAApB,C;IACA,QG9E4C,aH8E5C,EAAM,MAAN,EAAoB,UAApB,C;IACA,QG/E4C,aH+E5C,EAAM,KAAN,EAAmB,SAAnB,C;ICxHR,uBA6DoG,CEpBhC,aFvClE,SA2DkG,C;ED6DpG,C;;IAE0C,OE3EkB,CF2EjB,YAAO,GE3EU,UF2EG,CE3EH,CF2ElB,GAA0B,G;EAA1B,C;;IAGtC,iBAAU,I;IACV,iB;IACA,yB;EACJ,C;;IAII,Q;IADA,iBAAU,K;IACV,uE;EACJ,C;EE3HJ,gE;;IFgIc,4C;qBAAA,uF;UAAA,S;eAAA,Q;;eAAA,uB;IAAA,C;EAAA,C;;IAAA,wC;IAAA,yB;IAAA,0D;IAAA,6B;IAAA,+B;IAAA,wC;EAIN,C;;;;;;;;;;qCEnIK,MAAM,0BAAN,C;YFgIW,4D;;YACc,gB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"}